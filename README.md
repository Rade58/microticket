# FORMMATING JSON YOU SENT FROM YOUR MICROSERVICE

OPET NAPOMINJEM, ISTO KAO STO SAM DEFINISO ILI ISTRIVE-UJEM KA TOME DA ERROR MESSAGE/S BUDE/U CONSISTANT ACROSS ALL MICROSERVICES; **TREBALO BI DA SE STARAM I DA DATA INSIDE RESPONSE BUDE U FORMATU KOJI JE CONSISTANT ACROSS ALL MICROSERVICES**

POGOTOVO KADA IMAS NA PRIMER RAZLICITE MICROSERVICE-OVE, KOJI KORISTE RAZLLICITE DATABASE-OVE, TREBA DA SE STARAS DA KADA IZVUCES DATA IZ TIH DATABASE-OVA

**NA PRIMER KAD IZVUCES DATA IZ MONGODB-JA TEBI JE DATA U TAKVOM FORMATU DA IMAS PROPERTIJE `_id`, ZATIM `__v`**

TAKVE PROPERTIJE NEMAJU DRUGI DATABASE-OVI

**A TI TREBA DO CLIENTA DA, SVE SALJES U ISTOM FORMATU, JER TVOJ REACT, ODNOSNO NEXTJS APP TREBA DA ZANA SAMO ZA JEDAN FORMAT JSON-A, KOJI MU SALJU TVOJI MICROSERVICE-OVI SA RESPONSE-OVIMA**

ISTO TAKO KADA KREIRAS, ILI SAMO GET-UJES USER OBJEKAT, TI NE BI TREBAL ODA POSALJES U RESPONS-U CELOKUPAN OBJEKAT, VEC SAMO BASIC STUFF: `email` `id`

NARAVNO NE TREBAS DA SALJES PASSWORD BEZ OBZIRA STO JE PASSWORD HASHED

# HAJDE DA SE REMIND-UJEMO KAKO TO JAVASCRIPT TRANSFORMISE OBJECTS INTO JSON DATA, ODNOSNO STA SE TO DESAVA KADA KORISTIMO `JSON.stringify`

NAIME, OVA METODA UNDER THE HOOD KADA SE POZIVA, NE SAMO DA PARSE-UJE TVOJ OBJEKAT PRETVARAJUCI GA U JSON, VEC MU UMECE METODU `toJSON`, KOJOJJ DEFINISU DA RETURN-UJE ONO STA TREBA PARSE-OVATI, A KADA SE ZAVRSI PARSING METODA JE UKLONJENA IZ OBJEKATA

E PA TI MOZES OVERRIDE-OVATI TU `toJSON` METODU

EVO POKAZACU TI

```js
*> const foo = {prop: "something", toJSON(){return "bar"}}
<* undefined
*> JSON.stringify(foo)
<* ""bar""
```

KAO STO VIDIS USPESNO SAM OVERRIDE-OVAO POMENUTU METODU, ZA KOJU NISAM RANIJE NAO NI DA SE MOZE OVERRIDE-OVATI

# JA UPRAVO MOGU KORISTITI OVERRIDE TE `toJSON` METODE KAKO BI OSIGURAO DA KADA SE DATA DOSLA MA IZ KOJEG IZVORA (MA KOJEG DATABASE-A) FORMATIRA KAKO BI BILO CONSISTANT, ODNOSNO KAKO BI IMALO ISTI IZGLED











